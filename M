import pandas as pd

def slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency):
    # Ensure `res` is a DataFrame
    if not isinstance(res, pd.DataFrame):
        res = pd.DataFrame(res)

    # Convert frequency strings to fractions of a year
    def frequency_to_years(frequency):
        if frequency == "1Y":
            return 1.0
        elif frequency == "6M":
            return 0.5
        elif frequency == "3M":
            return 0.25
        else:
            raise ValueError("Unsupported frequency format.")

    # Calculate the number of periods (rows) for fixed and floating legs
    fixed_periods = int(swap_duration / frequency_to_years(fixed_frequency))
    floating_periods = int(swap_duration / frequency_to_years(floating_frequency))

    # Slice based on calculated number of rows for fixed and floating legs
    fixed_part = res.iloc[:fixed_periods]
    floating_part = res.iloc[fixed_periods:fixed_periods + floating_periods]

    return fixed_part, floating_part

# Example usage
swap_duration = 5  # 5 years
fixed_frequency = "6M"
floating_frequency = "3M"

# Assuming `res` is your pre-existing array or data structure
fixed_part, floating_part = slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency)

print("Fixed Leg Part:")
print(fixed_part)
print("\nFloating Leg Part:")
print(floating_part)












xxx

def slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency):
    # Convert frequencies to fractions of a year
    def frequency_to_years(frequency):
        if frequency == "1Y":
            return 1.0
        elif frequency == "6M":
            return 0.5
        elif frequency == "3M":
            return 0.25
        else:
            raise ValueError("Unsupported frequency format.")

    # Calculate the number of periods based on duration and frequency
    fixed_periods = int(swap_duration / frequency_to_years(fixed_frequency))
    floating_periods = int(swap_duration / frequency_to_years(floating_frequency))

    # Slice the fixed and floating parts of the table based on number of periods
    fixed_part = res[res["Leg"] == "Fixed"].iloc[:fixed_periods]
    floating_part = res[res["Leg"] == "Floating"].iloc[:floating_periods]

    return fixed_part, floating_part

# Example usage
swap_duration = 5  # 5 years
fixed_frequency = "6M"
floating_frequency = "3M"

# Assuming `res` is your pre-existing DataFrame
fixed_part, floating_part = slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency)

print("Fixed Leg Part:")
print(fixed_part)
print("\nFloating Leg Part:")
print(floating_part)






xxx

import numpy as np
import matplotlib.pyplot as plt

# Define the MtM function for a swap with dynamic slicing of cash flows and discount factors
def calculate_mtm_swap_over_time(notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, payment_frequency):
    num_periods = int(swap_duration * payment_frequency)
    time_points = np.arange(0, swap_duration, 1 / payment_frequency)  # Generate time points (every 6 months for 5 years)
    mtm_values = []  # To store MtM values at each time point

    for t in range(num_periods):
        # Remaining periods at each time point
        remaining_periods = num_periods - t
        
        # Slice the discount curve and float rate curve to get the remaining values
        current_discount_curve = discount_curve[t:t + remaining_periods]
        current_float_rate_curve = float_rate_curve[t:t + remaining_periods]
        
        # Fixed leg cash flows for remaining periods
        fixed_cash_flows = np.full(remaining_periods, notional * fixed_rate / payment_frequency)
        
        # Floating leg cash flows based on forward rates for remaining periods
        floating_cash_flows = notional * np.array(current_float_rate_curve) / payment_frequency
        
        # Present value of fixed leg
        pv_fixed_leg = np.sum(fixed_cash_flows * current_discount_curve)
        
        # Present value of floating leg
        pv_floating_leg = np.sum(floating_cash_flows * current_discount_curve)
        
        # Calculate MtM for the current period
        mtm_value = pv_fixed_leg - pv_floating_leg
        mtm_values.append(mtm_value)  # Append MtM value for this time point

    return time_points, mtm_values

# Define swap parameters for a 5-year swap
notional = 1000000  # 1 million
fixed_rate = 0.02  # 2% fixed rate (par rate)
swap_duration = 5  # 5 years
payment_frequency = 2  # semiannual payments

# Hypothetical forward Euribor rates for each payment period over 5 years (semiannual)
float_rate_curve = [0.015, 0.016, 0.017, 0.018, 0.019, 0.02, 0.021, 0.022, 0.023, 0.024] 

# Continuous discount factors for each period over 5 years (semiannual)
discount_curve = [0.99, 0.98, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.91, 0.90]

# Calculate MtM values over time
time_points, mtm_values = calculate_mtm_swap_over_time(
    notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, payment_frequency
)

# Plotting the MtM values over time
plt.plot(time_points, mtm_values, marker='o', linestyle='-')
plt.title("Mark-to-Market (MtM) Value of 5-Year Swap Over Time")
plt.xlabel("Time (Years)")
plt.ylabel("Mark-to-Market (MtM) Value")
plt.grid(True)
plt.show()
