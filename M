import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def calculate_mtm_swap_over_time(notional, fixed_rate, res, swap_duration, fixed_frq, floating_frq):
    # Number of periods based on frequencies
    num_fixed_periods = int(swap_duration * fixed_frq)
    num_floating_periods = int(swap_duration * floating_frq)
    
    # Time points for each fixed payment
    fixed_time_points = np.arange(0, swap_duration, 1 / fixed_frq)

    mtm_values = []

    for t in range(num_fixed_periods):
        # Calculate remaining periods
        remaining_fixed_periods = num_fixed_periods - t
        floating_index = int(t * (floating_frq / fixed_frq))
        remaining_floating_periods = num_floating_periods - floating_index

        # Slicing res for each leg
        fixed_part = res.iloc[t:t + remaining_fixed_periods]
        floating_part = res.iloc[floating_index:floating_index + remaining_floating_periods]

        # Fixed leg cash flows
        fixed_cash_flows = np.full(remaining_fixed_periods, notional * fixed_rate / fixed_frq)
        pv_fixed_leg = np.sum(fixed_cash_flows * fixed_part["Discount Factor"].values)

        # Floating leg cash flows
        floating_cash_flows = notional * floating_part["Forward Rate"].values / floating_frq
        pv_floating_leg = np.sum(floating_cash_flows * floating_part["Discount Factor"].values)

        # Calculate MtM and store
        mtm_value = pv_fixed_leg - pv_floating_leg
        mtm_values.append(mtm_value)

    return fixed_time_points, mtm_values

# Example usage
notional = 100000000
fixed_rate = 0.02
swap_duration = 5
fixed_frq = 2
floating_frq = 4

# Example res table
data = {
    "Discount Factor": [0.99, 0.98, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.91, 0.90,
                        0.89, 0.88, 0.87, 0.86, 0.85, 0.84, 0.83, 0.82, 0.81, 0.80],
    "Forward Rate": [0.015, 0.016, 0.017, 0.018, 0.019, 0.02, 0.021, 0.022, 0.023, 0.024,
                     0.025, 0.026, 0.027, 0.028, 0.029, 0.03, 0.031, 0.032, 0.033, 0.034]
}
res = pd.DataFrame(data)

# Calculate and plot
time_points, mtm_values = calculate_mtm_swap_over_time(
    notional, fixed_rate, res, swap_duration, fixed_frq, floating_frq
)

plt.plot(time_points, mtm_values, marker='o', linestyle='-')
plt.title("Mark-to-Market (MtM) Value of 5-Year Swap Over Time (Semiannual vs Quarterly)")
plt.xlabel("Time (Years)")
plt.ylabel("Mark-to-Market (MtM) Value")
plt.grid(True)
plt.show()







xxx



import numpy as np
import matplotlib.pyplot as plt

def calculate_mtm_swap_over_time(notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, fixed_frq, floating_frq):
    # Determine the number of periods for fixed and floating legs based on frequencies
    num_fixed_periods = int(swap_duration * fixed_frq)
    num_floating_periods = int(swap_duration * floating_frq)

    # Generate time points for the fixed leg (assuming we calculate MtM at fixed payment points)
    fixed_time_points = np.arange(0, swap_duration, 1 / fixed_frq)

    # Prepare to store MtM values over time
    mtm_values = []

    # Calculate MtM at each fixed payment point
    for t in range(num_fixed_periods):
        # Calculate remaining periods dynamically for both legs
        remaining_fixed_periods = num_fixed_periods - t
        remaining_floating_periods = num_floating_periods - int(t * (floating_frq / fixed_frq))

        # Slice discount curve and float rate curve dynamically based on remaining periods
        current_fixed_discount_curve = discount_curve[t:t + remaining_fixed_periods]
        current_floating_discount_curve = discount_curve[t * floating_frq // fixed_frq:t * floating_frq // fixed_frq + remaining_floating_periods]
        
        # Fixed leg cash flows for the remaining periods
        fixed_cash_flows = np.full(remaining_fixed_periods, notional * fixed_rate / fixed_frq)
        
        # Floating leg cash flows using sliced forward rate curve
        floating_cash_flows = notional * np.array(float_rate_curve[t * floating_frq // fixed_frq:t * floating_frq // fixed_frq + remaining_floating_periods]) / floating_frq

        # Present value of fixed and floating legs
        pv_fixed_leg = np.sum(fixed_cash_flows * current_fixed_discount_curve)
        pv_floating_leg = np.sum(floating_cash_flows * current_floating_discount_curve)
        
        # Calculate MtM and store
        mtm_value = pv_fixed_leg - pv_floating_leg
        mtm_values.append(mtm_value)

    return fixed_time_points, mtm_values

# Define swap parameters for a 5-year swap
notional = 1000000  # 1 million
fixed_rate = 0.02  # 2% fixed rate (par rate)
swap_duration = 5  # 5 years
fixed_frq = 2  # Semiannual for fixed leg (2 periods per year)
floating_frq = 4  # Quarterly for floating leg (4 periods per year)

# Hypothetical forward Euribor rates for each payment period over 5 years (quarterly)
float_rate_curve = [0.015, 0.016, 0.017, 0.018, 0.019, 0.02, 0.021, 0.022, 0.023, 0.024,
                    0.025, 0.026, 0.027, 0.028, 0.029, 0.03, 0.031, 0.032, 0.033, 0.034]

# Continuous discount factors for each period over 5 years (quarterly)
discount_curve = [0.99, 0.98, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.91, 0.90,
                  0.89, 0.88, 0.87, 0.86, 0.85, 0.84, 0.83, 0.82, 0.81, 0.80]

# Calculate MtM values over time
time_points, mtm_values = calculate_mtm_swap_over_time(
    notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, fixed_frq, floating_frq
)

# Plotting the MtM values over time
plt.plot(time_points, mtm_values, marker='o', linestyle='-')
plt.title("Mark-to-Market (MtM) Value of 5-Year Swap Over Time with Different Frequencies")
plt.xlabel("Time (Years)")
plt.ylabel("Mark-to-Market (MtM) Value")
plt.grid(True)
plt.show()










xxxx

import numpy as np
import matplotlib.pyplot as plt

def calculate_mtm_swap_over_time(notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, fixed_frq, floating_frq):
    # Determine the number of periods for fixed and floating legs based on frequencies
    num_fixed_periods = int(swap_duration * fixed_frq)
    num_floating_periods = int(swap_duration * floating_frq)

    # Generate time points for the fixed leg (assuming we calculate MtM at fixed payment points)
    fixed_time_points = np.arange(0, swap_duration, 1 / fixed_frq)

    # Prepare to store MtM values over time
    mtm_values = []

    # Calculate MtM at each fixed payment point
    for t in range(num_fixed_periods):
        # Calculate remaining periods dynamically for both legs
        remaining_fixed_periods = num_fixed_periods - t
        remaining_floating_periods = num_floating_periods - int(t * (floating_frq / fixed_frq))

        # Slice discount curve and float rate curve dynamically based on remaining periods
        current_fixed_discount_curve = discount_curve[t:t + remaining_fixed_periods]
        current_floating_discount_curve = discount_curve[t * floating_frq // fixed_frq:t * floating_frq // fixed_frq + remaining_floating_periods]
        
        # Fixed leg cash flows
        fixed_cash_flows = np.full(remaining_fixed_periods, notional * fixed_rate / fixed_frq)
        
        # Floating leg cash flows using sliced forward rate curve
        floating_cash_flows = notional * np.array(float_rate_curve[:remaining_floating_periods]) / floating_frq

        # Present value of fixed and floating legs
        pv_fixed_leg = np.sum(fixed_cash_flows * current_fixed_discount_curve)
        pv_floating_leg = np.sum(floating_cash_flows * current_floating_discount_curve)
        
        # Calculate MtM and store
        mtm_value = pv_fixed_leg - pv_floating_leg
        mtm_values.append(mtm_value)

    return fixed_time_points, mtm_values

# Define swap parameters for a 5-year swap
notional = 1000000  # 1 million
fixed_rate = 0.02  # 2% fixed rate (par rate)
swap_duration = 5  # 5 years
fixed_frq = 2  # Semiannual for fixed leg (2 periods per year)
floating_frq = 4  # Quarterly for floating leg (4 periods per year)

# Hypothetical forward Euribor rates for each payment period over 5 years (quarterly)
float_rate_curve = [0.015, 0.016, 0.017, 0.018, 0.019, 0.02, 0.021, 0.022, 0.023, 0.024,
                    0.025, 0.026, 0.027, 0.028, 0.029, 0.03, 0.031, 0.032, 0.033, 0.034]

# Continuous discount factors for each period over 5 years (quarterly)
discount_curve = [0.99, 0.98, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.91, 0.90,
                  0.89, 0.88, 0.87, 0.86, 0.85, 0.84, 0.83, 0.82, 0.81, 0.80]

#









xxx

import pandas as pd

def slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency):
    # Ensure `res` is a DataFrame
    if not isinstance(res, pd.DataFrame):
        res = pd.DataFrame(res)

    # Convert frequency strings to fractions of a year
    def frequency_to_years(frequency):
        if frequency == "1Y":
            return 1.0
        elif frequency == "6M":
            return 0.5
        elif frequency == "3M":
            return 0.25
        else:
            raise ValueError("Unsupported frequency format.")

    # Calculate the number of periods (rows) for fixed and floating legs
    fixed_periods = int(swap_duration / frequency_to_years(fixed_frequency))
    floating_periods = int(swap_duration / frequency_to_years(floating_frequency))

    # Slice based on calculated number of rows for fixed and floating legs
    fixed_part = res.iloc[:fixed_periods]
    floating_part = res.iloc[fixed_periods:fixed_periods + floating_periods]

    return fixed_part, floating_part

# Example usage
swap_duration = 5  # 5 years
fixed_frequency = "6M"
floating_frequency = "3M"

# Assuming `res` is your pre-existing array or data structure
fixed_part, floating_part = slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency)

print("Fixed Leg Part:")
print(fixed_part)
print("\nFloating Leg Part:")
print(floating_part)












xxx

def slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency):
    # Convert frequencies to fractions of a year
    def frequency_to_years(frequency):
        if frequency == "1Y":
            return 1.0
        elif frequency == "6M":
            return 0.5
        elif frequency == "3M":
            return 0.25
        else:
            raise ValueError("Unsupported frequency format.")

    # Calculate the number of periods based on duration and frequency
    fixed_periods = int(swap_duration / frequency_to_years(fixed_frequency))
    floating_periods = int(swap_duration / frequency_to_years(floating_frequency))

    # Slice the fixed and floating parts of the table based on number of periods
    fixed_part = res[res["Leg"] == "Fixed"].iloc[:fixed_periods]
    floating_part = res[res["Leg"] == "Floating"].iloc[:floating_periods]

    return fixed_part, floating_part

# Example usage
swap_duration = 5  # 5 years
fixed_frequency = "6M"
floating_frequency = "3M"

# Assuming `res` is your pre-existing DataFrame
fixed_part, floating_part = slice_table_by_frequency(res, swap_duration, fixed_frequency, floating_frequency)

print("Fixed Leg Part:")
print(fixed_part)
print("\nFloating Leg Part:")
print(floating_part)






xxx

import numpy as np
import matplotlib.pyplot as plt

# Define the MtM function for a swap with dynamic slicing of cash flows and discount factors
def calculate_mtm_swap_over_time(notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, payment_frequency):
    num_periods = int(swap_duration * payment_frequency)
    time_points = np.arange(0, swap_duration, 1 / payment_frequency)  # Generate time points (every 6 months for 5 years)
    mtm_values = []  # To store MtM values at each time point

    for t in range(num_periods):
        # Remaining periods at each time point
        remaining_periods = num_periods - t
        
        # Slice the discount curve and float rate curve to get the remaining values
        current_discount_curve = discount_curve[t:t + remaining_periods]
        current_float_rate_curve = float_rate_curve[t:t + remaining_periods]
        
        # Fixed leg cash flows for remaining periods
        fixed_cash_flows = np.full(remaining_periods, notional * fixed_rate / payment_frequency)
        
        # Floating leg cash flows based on forward rates for remaining periods
        floating_cash_flows = notional * np.array(current_float_rate_curve) / payment_frequency
        
        # Present value of fixed leg
        pv_fixed_leg = np.sum(fixed_cash_flows * current_discount_curve)
        
        # Present value of floating leg
        pv_floating_leg = np.sum(floating_cash_flows * current_discount_curve)
        
        # Calculate MtM for the current period
        mtm_value = pv_fixed_leg - pv_floating_leg
        mtm_values.append(mtm_value)  # Append MtM value for this time point

    return time_points, mtm_values

# Define swap parameters for a 5-year swap
notional = 1000000  # 1 million
fixed_rate = 0.02  # 2% fixed rate (par rate)
swap_duration = 5  # 5 years
payment_frequency = 2  # semiannual payments

# Hypothetical forward Euribor rates for each payment period over 5 years (semiannual)
float_rate_curve = [0.015, 0.016, 0.017, 0.018, 0.019, 0.02, 0.021, 0.022, 0.023, 0.024] 

# Continuous discount factors for each period over 5 years (semiannual)
discount_curve = [0.99, 0.98, 0.97, 0.96, 0.95, 0.94, 0.93, 0.92, 0.91, 0.90]

# Calculate MtM values over time
time_points, mtm_values = calculate_mtm_swap_over_time(
    notional, fixed_rate, float_rate_curve, discount_curve, swap_duration, payment_frequency
)

# Plotting the MtM values over time
plt.plot(time_points, mtm_values, marker='o', linestyle='-')
plt.title("Mark-to-Market (MtM) Value of 5-Year Swap Over Time")
plt.xlabel("Time (Years)")
plt.ylabel("Mark-to-Market (MtM) Value")
plt.grid(True)
plt.show()
